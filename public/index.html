<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>AsylumGram Fix</title>
    <style>
        body { font-family: sans-serif; background: #222; color: white; text-align: center; }
        video { width: 320px; border: 2px solid #555; margin: 10px; border-radius: 8px; background: #000; }
        #controls { margin-top: 20px; display: none; }
        .admin-only { display: none; background: #444; padding: 15px; margin: 10px; }
        button { padding: 10px 20px; cursor: pointer; margin: 5px; }
    </style>
</head>
<body>

    <div id="auth">
        <input type="text" id="user" placeholder="–õ–æ–≥–∏–Ω">
        <input type="password" id="pass" placeholder="–ü–∞—Ä–æ–ª—å">
        <button onclick="login()">–í–æ–π—Ç–∏</button>
    </div>

    <div id="main" style="display:none">
        <div id="admin-box" class="admin-only">
            <input type="text" id="gname" placeholder="–ò–º—è –≥—Ä—É–ø–ø—ã">
            <button onclick="makeGroup()">‚ûï –°–æ–∑–¥–∞—Ç—å –≥—Ä—É–ø–ø—É</button>
        </div>

        <div id="groups"></div>
        
        <div id="video-ui">
            <video id="local" autoplay muted playsinline></video>
            <video id="remote" autoplay playsinline></video>
            <br>
            <button id="scrBtn" onclick="toggleScreen()">üñ•Ô∏è –≠–∫—Ä–∞–Ω</button>
            <button onclick="location.reload()">‚ùå –°–±—Ä–æ—Å</button>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        let localStream, peer, screenStream;

        async function login() {
            const username = document.getElementById('user').value;
            socket.emit('login', { username, password: document.getElementById('pass').value }, (res) => {
                if(res.success) {
                    document.getElementById('auth').style.display = 'none';
                    document.getElementById('main').style.display = 'block';
                    if(res.isAdmin) document.getElementById('admin-box').style.display = 'block';
                    initCamera();
                }
            });
        }

        async function initCamera() {
            localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            document.getElementById('local').srcObject = localStream;
        }

        function makeGroup() {
            const name = document.getElementById('gname').value;
            if(name) socket.emit('create-group', name);
        }

        socket.on('group-available', (name) => {
            const b = document.createElement('button');
            b.innerText = "–ì—Ä—É–ø–ø–∞: " + name;
            b.onclick = () => { socket.emit('join-group', name); };
            document.getElementById('groups').appendChild(b);
        });

        // –§–ò–ö–° –≠–ö–†–ê–ù–ê: –∑–∞–º–µ–Ω—è–µ–º —Ç—Ä–µ–∫ –≤ —Ç–µ–∫—É—â–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–∏
        async function toggleScreen() {
            if (!screenStream) {
                screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
                const track = screenStream.getVideoTracks()[0];
                
                if (peer) {
                    const sender = peer.getSenders().find(s => s.track.kind === 'video');
                    sender.replaceTrack(track); // –í–æ—Ç —ç—Ç–æ —á–∏–Ω–∏—Ç –±–∞–≥
                }
                document.getElementById('local').srcObject = screenStream;
                track.onended = () => toggleScreen();
            } else {
                screenStream.getTracks().forEach(t => t.stop());
                screenStream = null;
                const videoTrack = localStream.getVideoTracks()[0];
                if (peer) {
                    const sender = peer.getSenders().find(s => s.track.kind === 'video');
                    sender.replaceTrack(videoTrack);
                }
                document.getElementById('local').srcObject = localStream;
            }
        }

        socket.on('incoming-call', async (d) => {
            await createPeer(d.fromSid);
            await peer.setRemoteDescription(new RTCSessionDescription(d.offer));
            const ans = await peer.createAnswer();
            await peer.setLocalDescription(ans);
            socket.emit('answer-call', { to: d.fromSid, answer: ans });
        });

        socket.on('call-answered', d => peer.setRemoteDescription(new RTCSessionDescription(d.answer)));
        socket.on('ice-candidate', d => peer.addIceCandidate(new RTCIceCandidate(d.candidate)));

        async function createPeer(sid) {
            peer = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
            localStream.getTracks().forEach(t => peer.addTrack(t, localStream));
            peer.ontrack = e => document.getElementById('remote').srcObject = e.streams[0];
            peer.onicecandidate = e => {
                if(e.candidate) socket.emit('ice-candidate', { to: sid, candidate: e.candidate });
            };
        }

        // –ê–≤—Ç–æ-–≤—ã–∑–æ–≤ –ø—Ä–∏ –≤—Ö–æ–¥–µ –≤ –≥—Ä—É–ø–ø—É
        socket.on('user-joined', async (d) => {
            await createPeer(d.sid);
            const offer = await peer.createOffer();
            await peer.setLocalDescription(offer);
            socket.emit('call-user', { to: d.sid, offer });
        });
    </script>
</body>
</html>